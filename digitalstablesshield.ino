
#include "Arduino.h"

#include <OLED.h>
#include <NoLCD.h>

#include <DiscreteRecord.h>

#include <avr/wdt.h>
#include <PowerManager.h>


/**
 * teleonome speciifc libraries
 */

#include <XBee.h>

XBee xbee = XBee();
XBeeResponse response = XBeeResponse();
// create reusable response objects for responses we expect to handle
ZBRxResponse rx = ZBRxResponse();
ModemStatusResponse msr = ModemStatusResponse();


/**
 * teleonome speciifc variables
 */
OLED oled;




static const char *LIFE_CYCLE_EVENT_SETUP_COMPLETED="Setup Method Completed";
static const int LIFE_CYCLE_EVENT_COMMA_VALUE=1;





GeneralFunctions generalFunctions;
TimeManager timeManager(generalFunctions, Serial);
SecretManager secretManager(timeManager);
SDCardManager sdCardManager(timeManager, generalFunctions, Serial, oled );
PowerManager aPowerManager(oled , secretManager , sdCardManager , timeManager, generalFunctions, Serial);




/**
 * Teleonome Specific Functions
 *  Generated by the Spermatogenesis process
 */

struct DiscreteRecord createDiscreteRecord(float la, float lo, int pan, int tag, uint8_t ss ){
	DiscreteRecord discrete;
	discrete.lon=lo;
	discrete.lat=la;
	discrete.timestamp = timeManager.getCurrentTimeInSeconds();
	discrete.panID=pan;
	discrete.tagId=tag;
	discrete.signalStrength=ss;
	return discrete;
}
/**
 * End of Teleonome Specific Functions
 */




/***************************************************
 *  Name:        ISR(WDT_vect)
 *
 *  Returns:     Nothing.
 *
 *  Parameters:  None.
 *
 *  Description: Watchdog Interrupt Service. This
 *               is executed when watchdog timed out.
 *
 ***************************************************/
ISR(WDT_vect){
	//lcd.setCursor(0, 1);
	//lcd.print("Waking Up") ;
	//wdt_reset();

	// uncomment
	aPowerManager.toggleWDT();



	//	if(f_wdt == 0)
	//	{
	//		f_wdt=1;
	//	}
	//	else
	//	{
	//		//_HardSerial.println("WDT Overrun!!!");
	//	}
}

void setup() {
	//
	// Start the Serial Ports
	//
	Serial.begin(9600);

	//
	// if Hermes is present
	//
	Serial1.begin(9600);

	//
	// if there is at least one XBee telepathon
	//
	xbee.begin(Serial2);

	//
	// if there is at least one RS485 telepathon
	//
	Serial3.begin(9600);

	//
	//the lcd screen
	//
	oled.begin();
	//	//
	//	// Start The Managers
	//	//
	oled.setCursor(0, 0);
	oled.clear();
	oled.print("Init Time Manager") ;
	oled.setCursor(0, 1);
	oled.print("1 of 3") ;
	timeManager.start();
	//
	oled.clear();
	oled.print("Init SDCard Manager") ;
	oled.setCursor(0, 1);
	oled.print("2 of 3") ;
	sdCardManager.start();
	//
	oled.clear();
	oled.print("Init Power Manager") ;
	oled.setCursor(0, 1);
	oled.print("3 of 3") ;
	aPowerManager.start();
	//
	long totalDiskUse=sdCardManager.getDiskUsage()/1024;


	oled.clear();
	oled.setCursor(0, 0);
	oled.print("Init Finished") ;
	oled.setCursor(0, 1);

	oled.setCursor(0, 1);
	oled.print("SD use ") ;
	oled.print(totalDiskUse) ;
	oled.print("Kb") ;

	//
	// end of initializing lcd
	//
	delay(1000);
	long now = timeManager.getCurrentTimeInSeconds();

	sdCardManager.storeLifeCycleEvent(now, LIFE_CYCLE_EVENT_SETUP_COMPLETED, LIFE_CYCLE_EVENT_COMMA_VALUE);
}


void loop() {

	wdt_reset();



	//
	// Generate the SensorData String


	//
	// now define the state its in
	//
	aPowerManager.defineState();
	//
	//
	// process every I2CTelepathon by calling it getSensorData();
	// firtDaughter is for Valentino only
	//
	firstDaughter.getSensorDataString();
	//
	//
	nose.getSensorDataString();
	//
	//
	// the serial ports
	// the code below depends on the structure of the teleonome. in the biggest case
	// you have three, Serial which corresponds to the hypothalamus connection which is always present
	// then Serial2 which represents the XBee and Serial3 which represents RS485
	if( Serial2.available() != 0) {
		//
		// the iTrough has a sensor string

	}
	//
	if( Serial.available() != 0) {
		//lcd.clear();

		String command = Serial.readString();
		//
		// end of teleonome specific sensors
		//



		boolean commandProcessed =  aPowerManager.processDefaultCommands( command);

		/*
		 * teleonome specific sensors
		 */

		/*
		 * end f teleonome specific sensors
		 */
		if(!commandProcessed){
			//
			// add device specific
			Sample

				oled.clear();

				oled.setCursor(0, 0);
				oled.print("b:");
				long b = millis();
				oled.print(b);
				String sensorDataString= aPowerManager.getBaseSensorString();
				int now = (int)(millis() - b);
				//
				// now add the teleonome specific sensors
				//

				oled.setCursor(0, 1);
				oled.print("e:");
					.print(now);


				Serial.println(sensorDataString);
				Serial.flush();
			}else if(command.startsWith("ReadDiscreteRecords")){
				boolean fileOk = sdCardManager.openDiscreteRecordFile();
				boolean keepGoing=true;
				DiscreteRecord discreteRecord;

				uint16_t index=0;
				if(fileOk){
					while(keepGoing){
						keepGoing = sdCardManager.readDiscreteRecord(index, discreteRecord);
						index++;
						if(keepGoing){
							//
							// if we are here is because we do have data
							// so extract it
							//
							// generated code
							//
							String discreteRecordString="";
							discreteRecordString.concat(discreteRecord.timestamp) ;
							discreteRecordString.concat("#") ;
							discreteRecordString.concat(discreteRecord.lat) ;
							discreteRecordString.concat("#") ;
							discreteRecordString.concat(discreteRecord.lon) ;
							discreteRecordString.concat("#") ;
							discreteRecordString.concat(discreteRecord.panID) ;
							discreteRecordString.concat("#") ;
							discreteRecordString.concat(discreteRecord.tagId) ;
							discreteRecordString.concat("#") ;
							discreteRecordString.concat(discreteRecord.signalStrength) ;
							discreteRecordString.concat("#") ;
							Serial.println(discreteRecordString);

						}
						Serial.println("Ok-ReadDiscreteRecords");
						Serial.flush();
					}
					sdCardManager.closeDiscreteRecordFile();
				}

			}else{
				//
				// call read to flush the incoming
				//
				Serial.read();
				Serial.println("Failure-Bad Command " + command);
				Serial.flush();
			}
		}

		// this is the end of the loop, to calculate the energy spent on this loop
		// take the time substract the time at the beginning of the loop (the now variable defined above)
		// and also substract the seconds spent in powerdownMode
		// finally add the poweredDownInLoopSeconds to the daily total

		aPowerManager.endOfLoopProcessing();

	}
}
